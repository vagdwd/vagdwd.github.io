/*
-----------
0. 247Conf
1. uAParser
2. tracker
3. sncustomxd
4. 247px
5. resourceloader
generated by psp: Tue Aug 27 07:40:09 UTC 2013-----------
*/
/*0. 247Conf*/
/**
 * @identity 247Conf
 */
if (typeof SN === "undefined") {
    SN = {};
}
/**
 * @module PE
 * @submodule SD
 */
/**
 * A class containing all the Client specific configurations allowed by the
 * platform. Content of this class is to be edited by the Service Delivery team
 * according to client requirements before being used and deployed.
 *
 * @class SN.Conf
 * @static
 */
SN.Conf = (function() {

    /**
     * Returns the encoded value of url for a web page.
     * The actual implementation of this method should be done when 247px.js is being configured for a client.
     *
     * @method getEncodedValue
     * @param {String} value The url of the page which needs to be encoded.
     * @example
     *      SN.Conf.getEncodedValue("http://247testsite.com/test.html");
     * @return {String} Id of given url.
     */
    function getEncodedValue(value){
//      if(value == "http://247testsite.com/test.html"){
//          return "h";
//          }else if(value == "abcd type of product category"){
//          return "a";
//          }else if(value == "in.yahoo.com"){
//              return "Y";
//          }else if(value == "www.google.co.in"){
//              return "G";
//          }
//          else{
//          return value;
//          }
        }

    /**
     * Returns the full url for a page id from a mapping defined by Service Delivery Group
     * The actual implementation of this method should be done when 247px.js is being configured for a client.
     *
     * @method getDecodedValue
     * @param {String} encodedValue The id of the page for which the url is required.
     * @example
     *      SN.Conf.getDecodedValue("id1");
     * @return {String} Page URL
     */
    function getDecodedValue(encodedValue) {
        // The actual implementation of this method should be done when 247px.js is being configured for a client.
        // Below is a sample implementation (in comments)
        //  switch (encodedValue) {
        //  case "<id1>":
        //      return "<client_page1>";
        //  case "<id2>":
        //      return "<client_page2>";
        //  default:
        //      return encodedValue;
        //  }
        return encodedValue;
    }

    /**
     * Returns an id corresponding to the current page url and the mapping
     * defined by Service Delivery Team.
     *
     * @method getUrlId
     * @example
     *      SN.Conf.getUrlId();
     * @return {String} Page URL
     */
    function getUrlId() {
        //The actual implementation of this method should be done when 247px.js is being configured for a client.
        //In the actual implementation, a specific id (max 2 characters) corresponding to the current page url should be returned.
        //Below (in comments) is a sample code on how to implement this method:
        //var presentUrl = window.location.href;
        //if (presentUrl.indexOf('client_page1') != -1)
        //    return "id1";
        //else if (presentUrl.indexOf('client_page2') != -1)
        //    return "id2";
        //return "id3";
        var presentUrl = window.location.protocol + '//' + window.location.host + window.location.pathname;
        var pattern_MatProd = new RegExp('.*mattress.*(/p-|/p_).*','i');    //Mattress Product Page
        var pattern_GenProd = new RegExp('.*(/p-|/p_).*');                  //Generic Product Page
        var pattern_Checkout = new RegExp('.*CheckOut.*','i');              //Checkout Page
        if(pattern_MatProd.test(presentUrl)){
            return "aa";
        }
        if(pattern_GenProd.test(presentUrl)){
            return "ab";
        }
        if(pattern_Checkout.test(presentUrl)){
            return "ac";
        }
        return "id";
    }
    return {
        /**
         * Client Key.
         * @property CONST_PSP_KEY
         * @type String
         * @default "<client_key>"
         * @final
         */
        CONST_PSP_KEY : "searsol-v1-001",
        /**
         * The domain for custom tracking calls.
         * @property CUSTOM_TRACK_SERVER
         * @type String
         * @default "cdn.247ilabs.com"
         * @final
         */
        CUSTOM_TRACK_SERVER : "searsolcdn.px.247-inc.com",
        /**
         * Map of domain vs. the relative path of 247SN.html file.
         * @property DOMAIN_VS_PARAMETIZED_PATH_AND_EXTENSION
         * @type Object
         * @default {
         *      "<domain>" : "<relative path of 247SN.html>/247SN.<extension(html/htm)>"
         * }
         * @final
         */
        DOMAIN_VS_PARAMETIZED_PATH_AND_EXTENSION : {
            "www.sears.com" : "/psp247/247SN.html",
            "www.kmart.com" : "/psp247/247SN.html"
        },
        /**
         * Filename of the framework file.
         * @property CONST_PXFWK_ID
         * @type String
         * @default "pxfwk.gz.js"
         * @final
         */
        CONST_PXFWK_ID : "pxfwk.gz.js",
        /**
         * The version of the static resources fetched from cloudfront. Change this
         * version accordingly.
         * @property CONST_CDN_VERSION
         * @type String
         * @default "v0.1"
         * @final
         */
        CONST_CDN_VERSION : "v0.2",
        /**
         * The version psp resources fetched from coudfront. Change this version accordingly.
         * @property CONST_PSP_VERSION
         * @type String
         * @default "default"
         * @final
         */
        CONST_PSP_VERSION : "default",
        /**
         * List of all the domains (or subdomains if cross domain is activated)
         * where we want the platform cookies to be present.
         * @property COOKIEPATH
         * @type Array|[String]
         * @default [ "<client domain>" ]
         * @final
         */
        COOKIEPATH : [ "sears.com","kmart.com" ],
        /**
         * List of all the invalid character or strings that we do not want to be
         * inserted into the platform cookies, by the platform code. Please add any
         * more charactes as per requirement.
         * @property INVALID_COOKIE_CHARACTERS
         * @type Array|[String]
         * @default ["&", ">", "<", "#", ";", "javascript", "\x00",
         *           "script", "ATTACK", "REPLACE", "STYLE", "%2F",
         *           "ALERT", "TRACE", "X_IGNORE", "X-NADA:", "GET",
         *           "\x7F", "%3C", ")", "(", "%3E", "APPEND",
         *           "SCRIPT", "attack", "replace", "style", "append",
         *           "alert", "trace", "x_ignore", "get", "x-nada:",
         *           "%3c", "%3e", "%2f", "JAVASCRIPT" , "\x7f", "?",
         *           "&lsquo;", "?", "&rsquo;", "&lt;", "&gt;"]
         * @final
         * @since 5.3.4
         */
        INVALID_COOKIE_CHARACTERS : ["&", ">", "<", "#", ";", "javascript", "\x00",
                                     "script", "ATTACK", "REPLACE", "STYLE", "%2F",
                                     "ALERT", "TRACE", "X_IGNORE", "X-NADA:", "GET",
                                     "\x7F", "%3C", ")", "(", "%3E", "APPEND",
                                     "SCRIPT", "attack", "replace", "style", "append",
                                     "alert", "trace", "x_ignore", "get", "x-nada:",
                                     "%3c", "%3e", "%2f", "JAVASCRIPT" , "\x7f", "?",
                                     "&lsquo;", "?", "&rsquo;", "&lt;", "&gt;"],
        /**
         * The root address of the psp server where the tracking calls will go.
         * @property PSP_ROOT
         * @type String
         * @default "psp.247ilabs.com"
         * @final
         */
        PSP_ROOT : "searsolpsp.px.247-inc.com",
        /**
         * The framework version that we want to load.
         * @property PSP_VERSION
         * @type String
         * @default "default"
         * @final
         */
        PSP_VERSION : "default",
        /**
         * The cloudfront path where static resources are hosted.
         * @property CDN_PATH
         * @type String
         * @default "d1af033869koo7.cloudfront.net/psp/"
         * @final
         */
        CDN_DOMAIN : "d1af033869koo7.cloudfront.net/psp/",
        /**
         * PxOE release version that is on production for the client.
         * @property PXOE_VERSION
         * @type String
         * @default "5.3.4" (changes with every release)
         * @final
         */
        PXOE_VERSION : "5.3.4.5",
        /**
         * PxOE tracking version that is on production for the client.
         * @property TRACKING_VERSION
         * @type String
         * @default "1.3" (changes with every release)
         * @final
         */
        TRACKING_VERSION : "1.3",
        getDecodedValue : getDecodedValue,
        /**
         * Boolean to configure whether Decision to serve the user is required or not.
         * @property IS_DS_REQUIRED
         * @type Boolean
         * @default true
         * @final
         */
        IS_DS_REQUIRED : true,
        getUrlId : getUrlId,

        //custom script variables
        /**
         * The psp root path where the server is hosted.
         * @property CONST_PSP_ROOT
         * @type String
         * @default "psp.247ilabs.com"
         * @final
         */
        CONST_PSP_ROOT : "searsolpsp.px.247-inc.com",
        /**
         * The cloudfront root path where static resources are hosted.
         * @property CONST_PSP_CDN_ROOT
         * @type String
         * @default "d1af033869koo7.cloudfront.net"
         * @final
         */
        CONST_PSP_CDN_ROOT : "d1af033869koo7.cloudfront.net",
        /**
         * A character corresponding to the environment of the machine.
         * <br>'p' stands for production environment.
         * <br>'t' stands for testing environment, like staging.
         * @property CONST_PSP_STAGE
         * @type String
         * @default "p"
         * @final
         */
        CONST_PSP_STAGE : "p",
        /**
         * The client key.
         * @property CONST_PSP_CLIENT_KEY
         * @type String
         * @default "<client-key>"
         * @final
         */
        CONST_PSP_CLIENT_KEY : "searsol-v1-001",
        /**
         * Path to the pspxd file to be loaded in the first iframe.
         * @property pspxdPath
         * @type String
         * @default "/pspxd.html"
         * @final
         */
        pspxdPath : "/pspxd.html",
        /**
         * Percentage of users that will be allowed to served based on a random number.
         * @property CONST_PSP_VISITOR_PERCENTAGE
         * @type Number|Percentage
         * @default 100
         * @final
         * @deprecated
         */
        CONST_PSP_VISITOR_PERCENTAGE : 100,
        /**
         * Path of the proxy server for third party communication.
         * @property PROXY_SERVER
         * @type String
         * @default "psp.247ilabs.com/tps/tpsp.php?"
         * @final
         */
        PROXY_SERVER : "searsolpsp.px.247-inc.com/tps/tpsp.php?",
        /**
         * Interval in milliseconds for the framework periodic poller.
         * @property pollingTime
         * @type Number
         * @default 10000
         * @final
         */
        pollingTime : 10000,
        /**
         * A key value pair for variables in DOM scope to be monitored.
         * @property varmap
         * @type Object
         * @default {
         *      "<key>" : "<value>"
         * }
         * @final
         * @deprecated
         */
        varmap : {
            "<key>" : "<value>"
        },
        /**
         * Boolean to enable the url tracking logic in the framework.
         * @property trackingUrlFlag
         * @type Boolean
         * @default false
         * @final
         */
        trackingUrlFlag : false,
        /**
         * Boolean to enable the variable tracking logic in the framework.
         * @property varMapFlag
         * @type Boolean
         * @default false
         * @final
         * @deprecated
         */
        varMapFlag : false,
        /**
         * A map containing variables along with their JavaScript expression which
         * needs to be tracked as FSM variables in the early page load tracking call.
         * @property FSM
         * @type Object
         * @default {
         *       currentPageUrl : "document.location.href",
         *       referrer : "parent.document.referrer",
         *       title : "parent.document.title",
         *       el : "SN.Conf.getDecodedValue(SN.CookieManager.readSNCookie(\"sn.eh\",\"el\"))"
         * }
         * @final
         * @deprecated These variables were tracked as a part of early page load cal,
         * which has been removed since PxOE version 5.3
         */
        FSM : {
            //<key> : <expression> ,//Add FSM key and values here as required
            currentPageUrl : "document.location.href",
            referrer : "parent.document.referrer",
            title : "parent.document.title",
            el : "SN.Conf.getDecodedValue(SN.CookieManager.readSNCookie(\"sn.eh\",\"el\"))"
        },
        /**
         * A map containing variables along with their JavaScript expression which
         * needs to be tracked as Extra Data variables in the early page load
         * tracking call.
         * @property ED
         * @type Object
         * @default {}
         * @final
         * @deprecated These variables were tracked as a part of early page load cal,
         * which has been removed since PxOE version 5.3
         */
        ED : {
        //<key> : <expression> ,//Add Extra Data key and values here as required
        // <key> : <expression>
        },
        /**
         * Percentage of users that will be served with the Test versin of the
         * framework
         * @property TEST_PERCENTAGE
         * @type Number|Percentage
         * @default 0
         * @final
         */
        TEST_PERCENTAGE : 0,
        /**
         * Percentage of users for which tracking will be enabled
         * framework
         * @property TRACKING PERCENTAGE
         * @type Number|Percentage
         * @default 100
         * @final
         */
        CUSTOM_TRACKING_PERCENTAGE : 0,
        /**
         * Percentage of users that will not be served based on a random number.
         * This percentage is only valid if SN.247PxConf.IS_DS_REQUIRED is true.
         * @property BYPASS_PERCENTAGE
         * @type Number|Percentage
         * @default 0
         * @final
         */
        BYPASS_PERCENTAGE : 50,
        /**
         * Maximum number characters allowed in the platform cookies combined.
         * @property MAX_COOKIE_SIZE
         * @type Number
         * @default 2000
         * @final
         * @since 5.3.4
         */
        MAX_COOKIE_SIZE : 2000,
        /**
         * Maximum number of overall cookies on the page after which, the platform
         * will drop some of the low priority cookies to give client some space.
         * @property MAX_COOKIE_COUNT_THRESHOLD
         * @type Number
         * @default 50
         * @final
         * @since 5.3.4
         */
        MAX_COOKIE_COUNT_THRESHOLD : 50,
        /**
         * After a max cookie count is acheived and platform has dropped some of the
         * platform cookies, once the total number of cookies reach below this value,
         * the platform recreates the deleted cookies.
         * @property MIN_COOKIE_COUNT_THRESHOLD
         * @type Number
         * @default 45
         * @final
         * @since 5.3.4
         */
        MIN_COOKIE_COUNT_THRESHOLD : 45,
        /**
         * List of cookies that are disabled by platform. Platform allows some
         * cookies to be disabled and to be never created on any page.
         * @property DISABLED_COOKIES
         * @type Array|String
         * @default []
         * @final
         * @example
         *      ["sn.ui", "sn.wt"]
         *      // Note
         *      // Only one or more of the following cookies can be disabled:
         *      //  sn.eh
         *      //  sn.wt
         *      //  sn.ui
         *      //  sn.vc
         * @since 5.3.4
         */
        DISABLED_COOKIES : [ ],
        CDN_PATH : "d1af033869koo7.cloudfront.net/psp/",
    //dataStore can be either "server" or "cookie" or "localstorage"
    dataStore : "server",
    // viStore can be "cookie" or "localstorage"
    viStore : "localstorage",
    viStoreName : "sn.vi",
    isViStoreSession : false,
    shouldMaintainVi : true
    };

}());
/*1. uAParser*/

/**
 * @identity uAParser
 * @requires 247Conf
 */
if (typeof SN === "undefined") {
    SN = {};
}

SN.Constants = (function(){
    var me = {
        /**
         * constants to be used in loader
         */
        UNDEFINED_STR : "undefined",

        //LOG Levels
        LOGLEVEL_ERROR : "e",
        LOGLEVEL_WARN : "w",
        LOGLEVEL_DEBUG : "d",
        LOGLEVEL_INFO : "i",
        //store names
        SN_BS_STORE_NAME : "sn.bs",
        SN_AS_STORE_NAME : "sn.as",
        SN_UI_STORE_NAME : "sn.ui",
        SN_VI_STORE_NAME : "sn.vi" ,
        SN_RN_STORE_NAME : "sn.rn",
        SN_EXIT_HISTORY_STORE_NAME: "sn.eh",
        SN_VARIABLE_STORE_NAME : "sn.vc",
        SN_WEBTRACKER_STORE_NAME : "sn.wt",
        SN_VISITOR_STORE_NAME : "sn.vi",
        IS_ENV_SUPPORTED_OR_NOT : "es",
        IS_CUSTOM_TRACKING_ENABLED : "cte",

        KEY_VALUE_SEPERATOR : '||',
        KEY_VALUE_SEPERATOR_OLD : '#',
        KEY_SEPERATOR : '~'
    };
    return me;
}());

SN.Utils = (function(){
    function undefinedOrNull(param) {
        return ((param == "undefined") || (param == null) || (param === "null"));
    }

    var me = {
        undefinedOrNull : undefinedOrNull
    };
    return me;
}());
SN.Logger = (function() {
    /*
     * a flag added to control logging.by default logging is off.
     */
    var SN_CONSTANTS = SN.Constants;
    var shouldLog = false;
    function consoleLog(message) {
        if (!shouldLog) {
            return;
        }
        if (typeof console != SN_CONSTANTS.UNDEFINED_STR) {
            console.log(message);
        }
    }
    var me = {
        consoleLog : consoleLog
    };
    return me;
   }());

/**
 * @module PE
 * @submodule SD
 */
/**
 * Class to parse the browser user agent and determine the browser, device and
 * OS details.
 * 
 * @class SN.UserAgentParser
 * @static
 */
SN.UserAgentParser = (function() {

    /**
     * Variable to hole the user agent of the browser.
     * @property browserIdentifier
     * @final
     * @type String
     * @private
     */
    var browserIdentifier = navigator.userAgent;
    /**
     * Placeholder for <i>unknown</i> string.
     * @property UNKNOWN
     * @final
     * @type String
     * @default "unknown"
     * @private
     */
    var UNKNOWN = "unknown";
    /**
     * Variable for browser details.
     * @property browserDetails
     * @final
     * @type String
     * @default UNKNOWN
     * @private
     */
    var browserDetails = UNKNOWN;
    /**
     * The key seperator in the user agent string.
     * @property KEY_SEPERATOR
     * @final
     * @type String
     * @default "~"
     * @private
     */
    var KEY_SEPERATOR = '~';
    /**
     * Variable for device details.
     * @property deviceDetails
     * @final
     * @type String
     * @default "others"
     * @private
     */
    var deviceDetails = "others";
    /**
     * Variable for device type.
     * @property deviceType
     * @final
     * @type String
     * @default "U"
     * @private
     */
    var deviceType = "U";
    /**
     * Variable for OS type.
     * @property OSType
     * @final
     * @type String
     * @default UNKNOWN
     * @private
     */
    var OSType = UNKNOWN;
    /**
     * Variable for OS version.
     * @property OSVersion
     * @final
     * @type String
     * @default UNKNOWN
     * @private
     */
    var OSVersion = UNKNOWN;
    /**
     * Reference to {{#crossLink "SN.Logger"}}{{/crossLink}}
     * @property logger
     * @final
     * @type Object
     * @private
     */
    var logger = SN.Logger;

    /**
     * Object containing a tree structure to cover all types of browsers. The
     * heirarchy maintained is OS > [type|version] > versions.
     * - Android and Unix are not covered in this list and will be handled separately.
     * @property OSList
     * @final
     * @type Object
     * @private
     */
    var OSList =
        {
            Win:    {   osType      : "Windows",
                        osVersion   : { "NT 5.1" : "XP",
                                        "NT 6.0" : "Vista",
                                        "NT 6.1" : "7",
                                        "NT 6.2" : "8" }
                    },
            Mac:    {   osType      : "MacOS",
                        osVersion   : { "Mac OS X 10_4" : "Tiger",
                                        "Mac OS X 10.4" : "Tiger",
                                        "Mac OS X 10_5" : "Leopard",
                                        "Mac OS X 10.5" : "Leopard",
                                        "Mac OS X 10_6" : "Snow Leopard",
                                        "Mac OS X 10.6" : "Snow Leopard" }
                    },
            Android:{
                        osType      : "Andriod",
                        osVersion : { "Android 4.1.1" : "4.1.1"}
                    },
            Linux:  {   osType      : "Linux",
                        osVersion   : { "Ubuntu"    : "Ubuntu",
                                        "CentOS"    : "CentOS",
                                        "Red Hat"   : "Red Hat",
                                        "Mandriva"  : "Mandriva",
                                        "Gentoo"    : "Gentoo",
                                        "Debian"    : "Debian",
                                        "Fedora"    : "Fedora" }
                    }
        };

    /**
     * Returns the vesion for Firefox, Chrome and Safari.
     * 
     * @method getChromeOrFirefoxOrSafariVersion
     * @param {String} browserName The browser string. One of the following:
     *        - "Firefox/"
     *        - "Version/"
     *        - "Chrome/"
     * @return {String} The version string.
     * @private
     */
    function getChromeOrFirefoxOrSafariVersion(browserName)
    {
        if(browserName!=null)
        {
            var splitAtBrowserName = browserIdentifier.split(browserName);
            var regex = /(\d+\.)+\d+/;
            var version = regex.exec(splitAtBrowserName[1]);
            return version[0];
        }
    }

    /**
     * Object contaning various browser with methods to get the version and
     * support type.
     * @property browserList
     * @final
     * @type Object
     * @example
     *      SN.UserAgentParser.browserList.Firefox.getVersion();
     */
    var browserList = 
        {
            Firefox:{   lowestSupportedVersion : "3.6",
                        blacklistedVersions : [],   // This will be an array of blacklisted versions; eg : - if its - ["14.0.1", "13.1.2"], neither of them would be supported. Similarily for others
                        
                        getVersion : function(){return getChromeOrFirefoxOrSafariVersion("Firefox/");}
                                
                    },
            Version:{   lowestSupportedVersion : "5",//all versions >=5 are supported
                        blacklistedVersions : [],   
                        getVersion : function(){return getChromeOrFirefoxOrSafariVersion("Version/");}
                    },
            Chrome: {   lowestSupportedVersion : "10",//all versions are >=10 supported
                        blacklistedVersions : [],   
                        getVersion : function(){return getChromeOrFirefoxOrSafariVersion("Chrome/");}
                    },
            MSIE:   {   lowestSupportedVersion : "8", //all versions >6 are supported
                        blacklistedVersions : [],   
                        getVersion : function(){
                            var regex = /MSIE (\d+\.)+\d+/;
                            var versionString = regex.exec(browserIdentifier);
                            var version = versionString[0].split(" ");
                            return version[1];
                        }
                    }
        };

    /**
     * Object contaning various types of devices with the user agent string that
     * fall into those devices.
     * @property allDevicesList
     * @final
     * @type Object
     * @private
     */
    var allDevicesList = 
        {
            Tablet: {   1 : ["android", "!mobile"], //android and not mobile
                        2 : ["ipad", "webkit"],
                        3 : ["playbook"],           //blackberry tablet
                        4 : ["kindle"],
                        5 : ["xoom"],               //Motorola xoom
                        6 : ["tablet"]
                    },
            Mobile: {   1 : ["iphone", "!ipad", "!ipod"],  
                        2 : ["blackberry"],
                        3 : ["android", "mobile"],
                        4 : ["iemobile"],
                        5 : ["windows phone"],
                        6 : ["nokia"],
                        7 : ["fennec"],     //Firefox's effort at mobile browser
                        8 : ["mib"],        //Motorola
                        9 : ["minimo"],     //Mozilla web browser
                        10: ["symbian"],    //mobile operating system
                        11: ["netfront"],   //Common embedded OS browser    
                        12: ["up.browser"], //common on some phones
                        13: ["openweb"],    //Transcoding by OpenWave server
                        14: ["opera mini"],
                        15: ["opera mobi"],
                        16: ["brew"],       //Detects whether the device is a Brew-powered device.
                        17: ["danger"],     //Detects the Danger Hiptop device.
                        18: ["hiptop"],     //Detects the Danger Hiptop device.
                        19: ["midp"],       //a mobile Java technology
                        20: ["webos"]       //For Palm's new WebOS devices
                    },
                    //only if it is not a tablet or a mobile, would the code flow come to this part of the map
                    //hence we only need to check for OS.
            Desktop:{   1 : ["windows"],
                        2 : ["linux"],
                        3 : ["os\s+[x9]"],
                        4 : ["solaris"],
                        5 : ["bsd"]
                    },
            Unknown:{   1 : ["others"]
                    }
        };

    /**
     * Checks whether the given input string belongs to a browser.
     * 
     * @method isBrowser
     * @param {String} browserName The key to be checked for being a browser.
     * @return {Boolean} true if the key belongs to a browser, like 'Firefox';
     *         false otherwise.
     * @example
     *      SN.UserAgentParser.isBrowser("Firefox");
     */
    function isBrowser(key)
    {
        if(key  == "Version")
        {   
            if((browserIdentifier.indexOf("Opera") == -1) && (browserIdentifier.indexOf("Safari") != -1))
                return (browserIdentifier.indexOf(key) != -1);
            else
                return false;
        }
        return (browserIdentifier.indexOf(key) != -1);
    }

    /**
     * Returns the OS type of the user.
     * 
     * @method getOSType
     * @return {String} The operating system type of the user, for ex. "MacOS".
     * @example
     *      SN.UserAgentParser.getOSType();
     */
    function getOSType() {
        return OSType;
    }

    /**
     * Returns the OS type and the device type of the user.
     * 
     * @method getDeviceDetails
     * @return {String} A string containing operating system type, device
     *         caegory and the device type of the user, for ex. "MacOS~T~ipad".
     * @example
     *      SN.UserAgentParser.getDeviceDetails();
     */
    function getDeviceDetails()
    {
        return OSType + KEY_SEPERATOR + deviceType + KEY_SEPERATOR + deviceDetails;
    }

    /**
     * Initializes the class to parse and identify the browser details of the user.
     * 
     * @method intializeBrowserDetails
     * @private
     */
    function intializeBrowserDetails()
    {
        for (var key in browserList) {
            if(isBrowser(key) == true) {
                browserDetails = key.toLowerCase().charAt(0);   // if chrome send 'c', firefox - 'f'
                if( browserDetails == 'v') // if safari, send 's'
                    browserDetails = 's';
                else if( browserDetails == 'm') // if IE, send 'i'
                    browserDetails = 'i';
                browserDetails = browserDetails + KEY_SEPERATOR + browserList[key].getVersion();
            }
        }
    }

    /**
     * Returns the string containing the locale/language of the browser.
     * 
     * @method getBrowserLanguage
     * @return {String} The language locale of the browser. For ex. "en-us"
     * @example
     *      SN.UserAgentParser.getBrowserLanguage();
     */
    function getBrowserLanguage()
    {   
        return (window.navigator.language) ? window.navigator.language : window.navigator.userLanguage;
    }

    /**
     * Returns the OS type and the device type of the user.
     * 
     * @method getBrowserDetails
     * @return {String} A string containing the browser of the user along with
     *         the version. For ex. 'f~18.0.1' (for Firefox 18.0.1).
     * @example
     *      SN.UserAgentParser.getBrowserDetails();
     */
    function getBrowserDetails()
    {   
        return browserDetails;
    }

    /**
     * Initializes the class to parse and identify the operating system type and
     * version of the user.
     * 
     * @method initializeOSTypeAndVersion
     * @private
     */
    function initializeOSTypeAndVersion()   {
        
        for(var OSString in OSList) {
            
            if(browserIdentifier.indexOf(OSString) != -1)   {
            
                var versionList = OSList[OSString].osVersion;
                OSType = OSList[OSString].osType;
            
                for(var versionKey in versionList)  {
                    
                    if(browserIdentifier.indexOf(versionKey) != -1) {
                        OSVersion = versionList[versionKey];
                    }
                }
            }
        }
        if(OSType == UNKNOWN)   {               //OSType is neither Windows, Linux nor MacOS; check for Android or UNIX
            var CONST_ANDROID_NAME = "Android";
            var index = -1;
            if (( index = browserIdentifier.indexOf(CONST_ANDROID_NAME)) != -1) {
                OSType = CONST_ANDROID_NAME;
                OSVersion = browserIdentifier.substring(index + 8, index + 11);
            }
            else if (browserIdentifier.indexOf("X11") != -1)
                OSType = "UNIX";
        }
        if (OSVersion != UNKNOWN) {
            OSType = OSType + '-' + OSVersion;
        }
    }

    /**
     * Initializes the class to parse and identify the device details of the user.
     * As per http://www.browserIdentifierstring.com
     * 
     * @method initializeDeviceDetails
     * @private
     */
    function initializeDeviceDetails() {
        try {
        
            var uAgentInLowercase = browserIdentifier.toLowerCase();
            var flag = 0;
            for( var deviceKey in allDevicesList) {         //deviceKey will have value : Tablet/Mobile/Desktop/Unknown
                if(flag == 1)
                    break;
                else{
                    var deviceList = allDevicesList[deviceKey];     //deviceList is the map with various devices of the type - deviceKey
                    for(var listKey in deviceList) {            //listKey - 1,2,3 ...
                        flag=1;
                        for ( var key in deviceList[listKey]) { //first key will be the one stored in deviceDetails
                            var stringTobeSearched = deviceList[listKey][key]; 
                            if(stringTobeSearched.charAt(0) == '!'){
                                //strings in the map starting with "!" should not be present in the userAgent
                                if(uAgentInLowercase.indexOf(stringTobeSearched.substring(1)) != -1) {
                                    flag = 0;break;
                                }
                            }
                            else {
                                if(uAgentInLowercase.indexOf(stringTobeSearched) == -1) {
                                    flag = 0;break;
                                }
                            }
                        }
                        if(flag == 1)       // we have found the correct device from the userAgent
                        {   
                            //extract the device Type
                            deviceType = deviceKey.charAt(0);
                            //storing the device in the deviceDetails. If none of them satisfies, deviceDetails will have the value "others"
                            deviceDetails = deviceList[listKey]["0"];
                            break;
                        }
                    }
                }
            }
        }catch(err)
        {
            logger.consoleLog("Error while initializing device details:",err);
        }
    }
        

    var me = {
        getOSType : getOSType,
        browserList : browserList,
        isBrowser : isBrowser,
        getBrowserDetails : getBrowserDetails,
        getBrowserLanguage : getBrowserLanguage,
        getDeviceDetails :getDeviceDetails
    };
    
    initializeOSTypeAndVersion();
    initializeDeviceDetails();
    intializeBrowserDetails();
    return me;
})();
/*2. tracker*/
/**
 * @identity tracker
 * @requires 247Conf, uAParser
 */

if (typeof SN === "undefined") {
    SN = {};
}
/**
 * @module PE
 */
/**
 * Class to make the funnel tracking calls.
 *
 * @class SN.loadTrackingScript
 * @constructor
 * @param {String} type The reason for the tracking call, or the type of the tracking call.
 * @param {String} vid The visitor id of the user.
 * @param {Object} ed Any extra data you need to pass in the call.
 * @param {String} root The url of the psp server to which the cal lis to be made.
 * @param {String} key The client key.
 * @param {String} logLevel The log level of the call.
 * @example
 *        SN.loadTrackingScript("CouldntDeterminePathAndExtensionFor247SN","","",CUSTOM_TRACK_SERVER,CONST_PSP_KEY);
 */
SN.loadTrackingScript = function(type, vid, ed, root, key, logLevel) {
    var SN_CONSTANTS = SN.Constants;
    try {
        var ts = new String(new Date().getTime());
        var pspTrack = document.createElement('script');
        pspTrack.type = 'text/javascript';
        var searchStr = "id=" + window.pspSNTrackingId + "&type=" + type + "&ts=" + ts;
        if (typeof vid !== SN_CONSTANTS.UNDEFINED_STR && vid != null) {
            searchStr = searchStr + "&vid=" + vid;
        }
        var pathname = window.location.pathname;
        if (pathname.length > 200) {
            pathname = pathname.substr(0, 200);
        }
        searchStr = searchStr + "&u=" + pathname;
        searchStr = searchStr + "&ll=" + logLevel;
        if (typeof ed !== SN_CONSTANTS.UNDEFINED_STR && ed != null && ed != "") {
            searchStr = searchStr + "&ed=" + ed;
        }
        if (searchStr.length > 2000) {
            searchStr = searchStr.substr(0, 2000);
        }
        pspTrack.id = "track-js" + ts;
        pspTrack.src = document.location.protocol + "//" + root + "/psp/" + key + "/" + SN.Conf.CONST_PSP_VERSION + "/cpxt.js?" + searchStr;
        var head = document.getElementsByTagName('head').item(0);
        void (head.appendChild(pspTrack));
    } catch (err) {
        if (typeof console != undefined) {
            SN.Logger.consoleLog("Error while sending custom tracking data "+err);
        }
    }
};

/**
 * Custom JSON converter which falls back to native JSON implementation when
 * available.
 *
 * @class JSON_247
 * @static
 */
var JSON_247 = (function() {

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
            escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
            gap, indent, meta = {
                // table of character substitutions
                '\b' : '\\b',
                '\t' : '\\t',
                '\n' : '\\n',
                '\f' : '\\f',
                '\r' : '\\r',
                '"' : '\\"',
                '\\' : '\\\\'
            }, rep;

    function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
               var c = meta[a];
            return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }

    function str(key, holder) {
        var i, // The loop counter.
        k, // The member key.
        v, // The member value.
        length, mind = gap, partial, value = holder[key];

        if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }
        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }
        switch (typeof value) {
            case 'string':
                return quote(value);
        
            case 'number':
                return isFinite(value) ? String(value) : 'null';
        
            case 'boolean':
            case 'null':
                return String(value);
            case 'object':
                if (!value) {
                return 'null';
                }
                gap += indent;
                partial = [];
                if (Object.prototype.toString.apply(value) === '[object Array]') {
                    length = value.length;
                    for (i = 0; i < length; i += 1) {
                        partial[i] = str(i, value) || 'null';
                    }
                    v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
                    gap = mind;
                    return v;
                }
                if (rep && typeof rep === 'object') {
                    length = rep.length;
                    for (i = 0; i < length; i += 1) {
                        k = rep[i];
                        if (typeof k === 'string') {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                } else {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                        }
                    }
                }
                v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
                gap = mind;
                return v;
        }
    }

    /**
     * Converts a serializable object to JSON String.
     * 
     * @method stringify
     * @param {Object} value The object you want to convert to string.
     * @param {Function|Array} [replacer] If a function, transforms values and
     *        properties encountered while stringifying; if an array, specifies
     *        the set of properties included in objects in the final string.
     * @param {String|Number} [space] If it is a number, successive levels in the
     *        stringification will each be indented by this many space characters
     *        (up to 10). If it is a string, successive levels will indented by
     *        this string (or the first ten characters of it).Using the tab
     *        character mimics standard pretty-print appearance.
     * @example
     *      JSON_247.stringify({ a: 2 }, null, "  ");
     */
    function stringify(value, replacer, space) {
        var i;
        gap = '';
        indent = '';
        if (typeof space === 'number') {
            for (i = 0; i < space; i += 1) {
                indent += ' ';
            }
        } else if (typeof space === 'string') {
            indent = space;
        }
        rep = replacer;
        if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
            throw new Error('JSON_247.stringify');
        }
        return str('', {
            '' : value
        });
    }

    /**
     * Parse a string as JSON, optionally transforming the value produced by parsing.
     * 
     * @method parse
     * @param {String} text The JSON string you want to convert back to object.
     * @param {Function} [reviver] This function is ultimately called with the
     *        empty string and the topmost value to permit transformation of the
     *        topmost value. Be certain to handle this case properly, usually by
     *        returning the provided value, or parse will return undefined.
     * @example
     *      JSON_247.parse("{ 'a': 2 }", null);
     */
    function parse(text, reviver) {
        var j;
    
        function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && typeof value === 'object') {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = walk(value, k);
                        if (v !== undefined) {
                            value[k] = v;
                        } else {
                            delete value[k];
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        }
        text = String(text);
        cx.lastIndex = 0;
        if (cx.test(text)) {
            text = text.replace(cx, function(a) {
                return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            });
        }
        if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').replace(
            /(?:^|:|,)(?:\s*\[)+/g, ''))) {
            j = eval('(' + text + ')');
            return typeof reviver === 'function' ? walk({
                '' : j
                }, '') : j;
        }
        throw new SyntaxError('JSON_247.parse');
    }
    var me = {
        parse : parse,
        stringify : stringify
    };
    return me;
})();

/**
 * Class implementing logging methods.
 * 
 * @class SN.Logger
 * @static
 */
SN.Logger = (function() {
    /*
     * a flag added to control logging.by default logging is off.
     */
    /**
     * Reference to {{#crossLink "SN.Constants"}}{{/crossLink}}
     * @property SN_CONSTANTS
     * @final
     * @type Object
     * @private
     */
    var SN_CONSTANTS = SN.Constants;
    /**
     * Boolean to enable/disable logging.
     * @property shouldLog
     * @type Boolean
     * @default false
     * @private
     */
    var shouldLog = false;

    /**
     * Logs a message on to the console if available.
     * 
     * @method consoleLog
     * @param {String} message The message to log.
     * @example
     *      SN.Tracker.consoleLog("Error on line 2");
     */
    function consoleLog(message) {
        if (!shouldLog) {
            return;
        }
        if (typeof console != SN_CONSTANTS.UNDEFINED_STR) {
            console.log(message);
        }
    }
    var me = {
        consoleLog : consoleLog
    };
    return me;
}());

/**
 * Class implementing methods to sanitize and report any invalid character in
 * cookies.
 * 
 * @class SN.CookieSanitizer
 * @static
 */
SN.CookieSanitizer = (function() {
    /**
     * Reference to SN.Conf.INVALID_COOKIE_CHARACTERS
     * @property badChars
     * @final
     * @type Array
     * @private
     */
    var badChars = SN.Conf.INVALID_COOKIE_CHARACTERS;
    /**
     * Length of the badChars array.
     * @property length
     * @final
     * @type Integer
     * @private
     */
    var length = badChars.length;

    /**
     * Sanitizes the cookie value, removing any invalid character found, and
     * making an error tracking cal to report the same.
     * 
     * @method sanitize
     * @param {String} cookieValue The value that is going to be stored in the cookie.
     * @example
     *      SN.CookieSanitizer.sanitize("sn.as=as||1;sn.eh=eh||google.com");
     */
    function sanitize(cookieValue) {
        if (typeof cookieValue != "string")
            return cookieValue;
        var sanitizedValue = cookieValue;
        for (var i = 0; i < length; ++i) {
            sanitizedValue = sanitizedValue.split(badChars[i]).join("");
        }
        if (sanitizedValue != cookieValue) {
            SN.loadTrackingScript("InvalidCharacterInCookie", "", "",
                                  SN.Conf.CUSTOM_TRACK_SERVER,
                                  SN.Conf.CONST_PSP_KEY,
                                  SN.Constants.LOGLEVEL_ERROR);
        }
        return sanitizedValue;
    }
    var me = {
        sanitize: sanitize
    };
    return me;
}());

/**
 * This class provides methods to load and make tracking calls and to handle
 * their responses.
 * 
 * @class SN.Tracker
 * @static
 */
SN.Tracker = (function() {
    /**
     * Reference to {{#crossLink "SN.Constants"}}{{/crossLink}}
     * @property SN_CONSTANTS
     * @final
     * @type Object
     * @private
     */
    var SN_CONSTANTS = SN.Constants;
    /**
     * Reference to {{#crossLink "SN.UserAgentParser"}}{{/crossLink}}
     * @property uAParser
     * @final
     * @type Object
     * @private
     */
    var uAParser = SN.UserAgentParser;
    /**
     * Reference to SN.Conf.FSM
     * @property fsmMap
     * @final
     * @type Object
     * @private
     */
    var fsmMap = SN.Conf.FSM;
    /**
     * Reference to SN.Conf.ED
     * @property ed
     * @final
     * @type Object
     * @private
     */
    var ed = SN.Conf.ED;
    /**
     * Placeholder for request id.
     * @property CONST_REQUEST_ID
     * @final
     * @type String
     * @default "r"
     * @private
     */
    var CONST_REQUEST_ID = "r";
    /**
     * Placeholder for tracking data.
     * @property CONST_TRACKING_DATA
     * @final
     * @type String
     * @default "d"
     * @private
     */
    var CONST_TRACKING_DATA = "d";
    /**
     * Placeholder for Microsoft IE.
     * @property CONST_IE
     * @final
     * @type String
     * @default "MSIE"
     * @private
     */
    var CONST_IE = "MSIE";
    /**
     * Placeholder for Safari.
     * @property CONST_SAFARI
     * @final
     * @type String
     * @default "Safari"
     * @private
     */
    var CONST_SAFARI = "Safari";
    /**
     * Placeholder for retry count.
     * @property CONST_RETRY_COUNT
     * @final
     * @type String
     * @default "retryCount"
     * @private
     */
    var CONST_RETRY_COUNT = "retryCount";
    /**
     * Placeholder for request time.
     * @property CONST_REQUEST_TIME
     * @final
     * @type String
     * @default "requestTime"
     * @private
     */
    var CONST_REQUEST_TIME = "requestTime";
    /**
     * Placeholder for request parameters.
     * @property CONST_REQUEST_PARAM
     * @final
     * @type String
     * @default "requestParam"
     * @private
     */
    var CONST_REQUEST_PARAM = "requestParam";
    /**
     * Placeholder for secured tracking string.
     * @property CONST_TRACKING_SECURED
     * @final
     * @type String
     * @default "trackingSecured"
     * @private
     */
    var CONST_TRACKING_SECURED = "trackingSecured";
    /**
     * Variable which stores the tracking request object for each tracking call.
     * @property eventStorage
     * @final
     * @type Object
     * @default {}
     * @private
     */
    var eventStorage = {};
    /**
     * Reference to SN.Conf.CONST_PSP_VERSION
     * @property pspVersion
     * @final
     * @type String
     * @private
     */
    var pspVersion = SN.Conf.CONST_PSP_VERSION;
    /**
     * Time interval in milliseconds for the tracking script retry logic.
     * @property CONST_POLLING_TIME_INTERVAL
     * @final
     * @type Number
     * @default 3000
     * @private
     */
    var CONST_POLLING_TIME_INTERVAL = 3000;
    /**
     * Number of maximm reetrys allowed for a tracking script, if it fails.
     * @property MAX_RETRY_COUNT
     * @final
     * @type Number
     * @default 3
     * @private
     */
    var MAX_RETRY_COUNT = 3;
    /**
     * Time in milliseconds for which the framework waits for the tracking
     * script to return response before it considers as a timeout.
     * @property CONST_TIME_OUT
     * @final
     * @type Number
     * @default 2000
     * @private
     */
    var CONST_TIME_OUT = 2000;
    /**
     * An incrementing id used to track the order of each tracking call on a page
     * load. Page load being tseq = 0;
     * @property tseq
     * @final
     * @type Number
     * @default -1
     * @private
     */
    var tseq = -1;
    /**
     * An incrementing id used to create the unique script tag id which is
     * inserted into the document head to make the tracking call.
     * @property sseq
     * @final
     * @type Number
     * @default -1
     * @private
     */
    var sseq = -1;
    /**
     * Unique Page id generated from the current timestamp.
     * @property uniquePageId
     * @final
     * @type Number
     * @default Date.Now()
     * @private
     */
    var uniquePageId = new Date().getTime();
    /**
     * Variable to hold the visitor id corresponding to the tracking call.
     * @property vi
     * @final
     * @type String
     * @private
     */
    var vi;
    /**
     * Variable to hold the browser session id corresponding to the tracking call.
     * @property vi
     * @final
     * @type String
     * @private
     */
    var bsid;
    /**
     * The maximum size of the tracking call URL. If the url size exceeds this
     * value, the tracking cal is chunked into pieces.
     * @property MAX_URL_SIZE
     * @final
     * @type Number
     * @private
     */
    var MAX_URL_SIZE;
    /**
     * The callback to be made when a tracking call's status gets update. The
     * callback is called with two arguments: the request id and the status flag. 
     * @property statusTracker
     * @final
     * @type Function
     * @private
     */
    var statusTracker;
    /**
     * Object to hold the number of pending chunks for each tracking request.
     * @property status
     * @final
     * @type Object
     * @default {}
     * @private
     */
    var status = {};
    /**
     * Variable to hold the visitor group corresponding to the tracking call.
     * @property vg
     * @final
     * @type String
     * @private
     */
    var vg;
    /**
     * Variable to hold the target population corresponding to the tracking call.
     * @property tp
     * @final
     * @type String
     * @private
     */
    var tp;
    /**
     * Variable to hold the target id corresponding to the tracking call.
     * @property ti
     * @final
     * @type String
     * @private
     */
    var ti;
    /**
     * Variable to hold the random number for the target group determination
     * corresponding to the tracking call.
     * @property rt
     * @final
     * @type String
     * @private
     */
    var rt;
    /**
     * Variable to hold the random number for the visitor group determination
     * corresponding to the tracking call.
     * @property rv
     * @final
     * @type String
     * @private
     */
    var rv;

    /**
     * Makes all the pending tracking calls.
     * 
     * @method poll
     * @private
     */
    function poll() {
        sendAll();
    }

    /**
     * Saves the tracking calls whose response is not yet recieved and the
     * visitor moves away from that page. This saved data will be used on the
     * next page to make these incomplete tracking calls again.
     * 
     * @method saveOnExit
     * @param {Object} arg Not used in the method anywhere.
     * @private
     */
    function saveOnExit(arg) {
        try {
            var jsonEventStorage = JSON_247.stringify(eventStorage);
            sessionStorage.setItem("sn.tdata", jsonEventStorage);
        } catch (err) {
            SN.Logger.consoleLog("SN.Tracker:Error storing event data "+ err);
        }
    }

    function init() {
        if (isIE() || isSafari()) {
            MAX_URL_SIZE = 1000;
            SN.Logger.consoleLog("SN.Tracker: browser type IE , setting url size to 2k");
        } else {
            MAX_URL_SIZE = 1700;
            SN.Logger.consoleLog("SN.Tracker: browser type is not IE , setting url size to 4k");
        }
        setInterval(poll, CONST_POLLING_TIME_INTERVAL);
    
        if ((typeof sessionStorage == SN_CONSTANTS.UNDEFINED_STR) || (SN.Utils.undefinedOrNull(sessionStorage))) {
            return;
        }
        
        
        try {
            if (window.addEventListener){
                window.addEventListener("unload", saveOnExit, false);            
            }
            else if (document.addEventListener){
                document.addEventListener("unload", saveOnExit, false);
            }
            else if (window.attachEvent){
                window.attachEvent("onunload",saveOnExit); 
            }
            var oldEventData = eval('(' + sessionStorage.getItem("sn.tdata") + ')');
            copyParams(oldEventData, eventStorage);
            sendAll();
        } catch (err) {
            SN.Logger.consoleLog("SN.Tracker:Error in accessing old session data "+ err);
        }
    }

    /**
     * Makes all the pending tracking calls.
     * 
     * @method sendAll
     * @private
     */
    function sendAll() {
        for ( var source_reqId in eventStorage) {
            var requestObj = eventStorage[source_reqId];
            var trackingSecured;
            if (requestObj[CONST_RETRY_COUNT] < MAX_RETRY_COUNT) {
                if ((new Date().getTime()) - requestObj[CONST_REQUEST_TIME] > CONST_TIME_OUT) {
                    requestObj[CONST_REQUEST_TIME] = new Date().getTime();
                    requestObj[CONST_RETRY_COUNT] = requestObj[CONST_RETRY_COUNT] + 1;
                    SN.Logger.consoleLog("SN.Tracker:Retrying It, retry count =" + requestObj[CONST_RETRY_COUNT] + ", request id =" + source_reqId);
                    trackingSecured = requestObj[CONST_TRACKING_SECURED];
                    makeTrackingCall(getDefaultUrl(trackingSecured), requestObj[CONST_REQUEST_PARAM]);
                }
            } else {
                SN.Logger.consoleLog("SN.Tracker:Removing event data , retry count =" + requestObj[CONST_RETRY_COUNT] + ", request id :" + source_reqId);
                delete eventStorage[source_reqId];
                updateStatus(source_reqId, "FAILED");
            }
        }

    }

    /**
     * Adds script tag into the head of the document to make the tracking call.
     * 
     * @method makeTrackingCall
     * @param {String} url The url of the script to add.
     * @param {Object} params The key value pairs that you want to add to the url
     *        as query string.
     * @private
     */
    function makeTrackingCall(url, params) {
        sseq++;
        var scriptId = "pt" + sseq;
        var head = document.getElementsByTagName('head').item(0);
        var pspTrack = document.createElement('script');
        pspTrack.type = 'text/javascript';
        pspTrack.id = scriptId;
        pspTrack.src = appendUrlParams(url, scriptId, params);
        pspTrack.async = true;
        void (head.appendChild(pspTrack));
    }

    /**
     * Processes the response of a tracking call.
     * 
     * @method processResponse
     * @param {Object} res The response object contaning the request id and status.
     * @example
     *      SN.Tracker.processResponse({code: 001, r:"123143133212-12334431232"});
     */
    function processResponse(res) {
        SN.Logger.consoleLog("SN.Tracker: Processing response");
        if (!SN.Utils.undefinedOrNull(res.code)) {
            SN.Logger.consoleLog("SN.Tracker: Got error response for r=" + res.r + " with error code= " + res.code);
            if (!SN.Utils.undefinedOrNull(eventStorage[res.r])) {
                delete eventStorage[res.r];
                updateStatus(res.r, "FAILED");
            }
        }
        if (!SN.Utils.undefinedOrNull(eventStorage[res.r])) {
            SN.Logger.consoleLog("SN.Tracker: Got success response for req =" + res.r + " ,  removing it");
            delete eventStorage[res.r];
            updateStatus(res.r);
        } else {
            SN.Logger.consoleLog("SN.Tracker: Got success response for req =" + res.r + " , but the response is already processed , so ignoring it");
        }
    }

    /**
     * Removes an element from the head of the document.
     * 
     * @method removeElement
     * @param {String} oldId The id of the element to be removed.
     * @example
     *      SN.Tracker.removeElement("sp123");
     */
    function removeElement(oldId) {
        var old = document.getElementById(oldId);
        if (old) {
            var head = document.getElementsByTagName('head').item(0);
            setTimeout(function() {
            try {
                head.removeChild(old);
            } catch (err) {
                SN.Logger.consoleLog('Could not remove pxt.js in 247px.js. '+ err);
            }
            }, 2000);
        }
    }

    /**
     * Retrieves the session data corresponding to the visitor.
     * 
     * @method getSessionData
     * @return {Object} The session data comprising of vi, vg, tp etc.
     * @private
     */
    function getSessionData() {
    /** 17th Aug'13 @Balaram - BEGIN - As same API has been used in wowpx for firing tracking events, where there would not be any sn_ifame writing alternate code block and exposing getSessionData as a public method
        TODO: Need to get these code changes reviewed
     **/
        var iframeContentWindow = document.getElementById("sn_iframe");
        if (SN.Utils.undefinedOrNull(iframeContentWindow)){
            iframeContentWindow = window;
            if (!SN.Utils.undefinedOrNull(iframeContentWindow.SN.StoreManager)
                    && !SN.Utils.undefinedOrNull(iframeContentWindow.SN.StoreManager.getDOMData)){
                var sessionData = iframeContentWindow.SN.StoreManager.getDOMData('custom_sessionData');
                return sessionData;
            } else {
                return null;
            }
        }else{
            iframeContentWindow = iframeContentWindow.contentWindow;        
        }
    /** @Balaram - END**/
        var activeSessionId;
        var activeSessionPresent;
        var sessionData = {};
        var VI_ASID_SEPARATOR = "-";
        if (SN.Utils.undefinedOrNull(vi)) {
        vi = iframeContentWindow.SN.StoreManager.getValueFromStore("sn.vi", "vi");
        }
        sessionData.vi = vi;
        var scope = iframeContentWindow.SN.StoreManager.getValueFromStore("sn.vi","sp");
        if(SN.Utils.undefinedOrNull(vg)||SN.Utils.undefinedOrNull(tp)||SN.Utils.undefinedOrNull(ti)||SN.Utils.undefinedOrNull(rt)||SN.Utils.undefinedOrNull(rv)){    
            vg = iframeContentWindow.SN.StoreManager.getValueFromStore("sn.as","vg");
    
            ti = iframeContentWindow.SN.StoreManager.getValueFromStore("sn.as","ti");
    
            tp = iframeContentWindow.SN.StoreManager.getValueFromStore("sn.as","tp");
    
            rt = iframeContentWindow.SN.StoreManager.getValueFromStore("sn.rn","rt");
            rv = iframeContentWindow.SN.StoreManager.getValueFromStore("sn.rn","rv");
        }
        sessionData.vg = vg;
    
        sessionData.ti = ti;
    
        sessionData.tp = tp;
    
        sessionData.rt = rt;
        sessionData.rv = rv;
    
        activeSessionPresent = iframeContentWindow.SN.StoreManager.getValueFromStore("sn.as","a");
        activeSessionId = iframeContentWindow.SN.StoreManager.getValueFromStore("sn.vi","as");
    
        if (!SN.Utils.undefinedOrNull(activeSessionId)) {
            if (!(activeSessionPresent == "t")) {
                sessionData.as = (parseInt(activeSessionId) + 1).toString();
            }
            else{
                sessionData.as = (activeSessionId).toString();
            }
    
        }
    
        sessionData.v = SN.Conf.CONST_PSP_VERSION;
        
        if (SN.Utils.undefinedOrNull(bsid)) {
            bsid = iframeContentWindow.SN.StoreManager.getValueFromStore("sn.vi","vi") + VI_ASID_SEPARATOR
            + iframeContentWindow.SN.StoreManager.getValueFromStore("sn.vi","as");
        }
        sessionData.bsid = bsid;
        
        sessionData.up = getUniquePageId();
        var liots = iframeContentWindow.SN.StoreManager.getValueFromStore("sn.vi","it");
        if (liots == null)
            liots = 0;
        sessionData.it = liots;
        tseq++;
        sessionData.tseq = tseq;
        return sessionData;
    }

    /**
     * Creates and returns the metda data for the client.
     * 
     * @method createMetaData
     * @return {Object} An object containg a single property named 'key' with
     *         the value as the client key.
     * @private
     */
    function createMetaData() {
        var metadata = {};
        metadata.key = SN.Conf.CONST_PSP_KEY;
        return metadata;
    }

    /**
     * Creates and makes a tracking call with the provided information.
     * 
     * @method constructAndMakeTrackingCall
     * @param {Object} metaData Client related meta information holding object.
     * @param {Object} eventData Event related data that comes as f.ec object in
     *        the tracking call JSON.
     * @param {Function} callBack The method to be called with the response
     *        whenever the status of the call changes. The function will be
     *        called with two argument - eventRequestId and statusFlag. See
     *        statusTracker for more information.
     * @param {Boolean} trackingSecured Boolean to decide whether secured http
     *        tracking is used or not.
     * @example
     *      SN.Tracker.constructAndMakeTrackingCall({key: "verizon-v1-001"},
     *                                              {ec:100001, ...},
     *                                              function callback(eventRequestId, statusFlag) {...},
     *                                              true);
     */
    function constructAndMakeTrackingCall(metaData, eventData, callBack, trackingSecured) {
        if (!SN.Utils.undefinedOrNull(callBack)) {
            statusTracker = callBack;
        }
        if(SN.Utils.undefinedOrNull(metaData)){
            metaData = createMetaData();
        }
        var url = getDefaultUrl(trackingSecured);
        var sessionData = getSessionData();
        eventData.vp = SN.Conf.PXOE_VERSION;
        eventData.vt = SN.Conf.TRACKING_VERSION;
        copyParams(sessionData, eventData);

        if(SN.Utils.undefinedOrNull(eventData.f)) {
            eventData.f ={};
        }
        if(SN.Utils.undefinedOrNull(eventData.f.v)) {
            eventData.f.v ={};
        }
        
        // sending browser details 
        eventData.f.v.br = uAParser.getBrowserDetails();
        //device Details and os details
        eventData.f.v.dd =  uAParser.getDeviceDetails();
        //timezone
        {    
            currDate = new Date();        //local variable.
            eventData.f.v.tz = currDate.getTimezoneOffset();
        }
        
        var requestId = getUniqueId();
        var trackingDatas = createTrackingData(eventData);
        var noOfTrackingDataParts = trackingDatas.length;
        status[requestId] = noOfTrackingDataParts;
        var sequenceId = 1;
        while (trackingDatas.length > 0) {
            var requestParam = {};
            requestParam[CONST_REQUEST_ID] = requestId + "-" + noOfTrackingDataParts + "-" + sequenceId;
            sequenceId++;
            try {
                copyParams(metaData, requestParam);
                requestParam[CONST_TRACKING_DATA] = trackingDatas.shift();
                save(requestParam, trackingSecured);
                SN.Logger.consoleLog("SN.Tracker: Got an event, assigning request id = " + requestParam[CONST_REQUEST_ID]);
                makeTrackingCall(url, requestParam);
            } catch (err) {
                SN.Logger.consoleLog("SN.Tracker:Exception while sending event data. request id:" + requestParam[CONST_REQUEST_ID] +" "+ err);
            }
        }
        return requestId;
    }

    /**
     * Saves the request object for a tracking call into eventStorage object.
     * 
     * @method save
     * @param {Object} requestParam The request object corresponding to the tracking call.
     * @param {Boolean} trackingSecured Boolean to enable secured http tracking call.
     * @private
     */
    function save(requestParam, trackingSecured) {
        var requestObj = {};
        requestObj[CONST_REQUEST_PARAM] = requestParam;
        requestObj[CONST_REQUEST_TIME] = new Date().getTime();
        requestObj[CONST_RETRY_COUNT] = 1;
        requestObj[CONST_TRACKING_SECURED] = trackingSecured;
        eventStorage[requestParam[CONST_REQUEST_ID]] = requestObj;
        SN.Logger.consoleLog("SN.Tracker: Successfully saved the request, req id = " + requestParam[CONST_REQUEST_ID]);
    }

    /**
     * Creates and generates the default tracking url.
     * 
     * @method getDefaultUrl
     * @param {Boolean} trackingSecured Boolean to enable secured http tracking call.
     * @return {String} The tracking url.
     * @private
     */
    function getDefaultUrl(trackingSecured) {
        if (!SN.Utils.undefinedOrNull(trackingSecured) && trackingSecured) {
            return "https:" + "//" + SN.Conf.PSP_ROOT + "/psp/" + SN.Conf.CONST_PSP_KEY + "/" + SN.Conf.CONST_PSP_VERSION + "/pxt.js?";
        }
        return document.location.protocol + "//" + SN.Conf.PSP_ROOT + "/psp/" + SN.Conf.CONST_PSP_KEY + "/" + SN.Conf.CONST_PSP_VERSION + "/pxt.js?";
    }

    /**
     * Creates the event data JSON string for the tracing call. Splits the data
     * in chunks if it exceeds GET call character limit.
     * 
     * @method createTrackingData
     * @param {Object} eventData The event data object that needs to be tracked
     *        in the tracking call.
     * @return {Array} Array containing the tracking event data in chunks.
     * @private
     */
    function createTrackingData(eventData) {
        var trackingData = {};
        trackingData.e = eventData;
        var trackigDataJSON = JSON_247.stringify(trackingData);
        var trackingDatas = [];
        for ( var i = 0; i < trackigDataJSON.length; i = i + MAX_URL_SIZE) {
            var end = i + MAX_URL_SIZE;
            if (trackigDataJSON.length <= i + MAX_URL_SIZE) {
                end = trackigDataJSON.length;
            }
            trackingDatas.push(trackigDataJSON.substring(i, end));
        }
        return trackingDatas;
    }

    /**
     * Checks if the user's browser is Internet Explorer.
     * 
     * @method isIE
     * @return {Boolean} True if the user's browser is Internet explore, false otherwise
     * @private
     */
    function isIE() {
        if (navigator.userAgent.indexOf(CONST_IE) != -1)
            return true;
        return false;
    }

    /**
     * Checks if the user's browser is Safari.
     * 
     * @method isSafari
     * @return {Boolean} True if the user's browser is Safari, false otherwise
     * @private
     */
    function isSafari() {
        if (navigator.userAgent.indexOf(CONST_SAFARI) != -1)
            return true;
        return false;
    }

    /**
     * Evaluates all the input expression in an object.
     * 
     * @method evaluate
     * @return {Object} The result for each of the expressions.
     * @private
     */
    function evaluate(inputExp) {
        var result = {};
        for ( var property in inputExp) {
            try {
                var value = eval(inputExp[property]);
                if ((value != null) && (value != SN_CONSTANTS.UNDEFINED_STR) && (value != 'null')) {
                    result[property] = eval(inputExp[property]);
                }
            } catch (err) {
                SN.Logger.consoleLog("PS: error in getting value for: " + property+ " "+ err);
            }
        }
        return result;
    }
  
    /**
     * Returns a unique string based on random number and timestamp combination.
     * 
     * @method getUniqueId
     * @return {String} Unique string made out of combination of timetamp and
     *         random number.
     * @private
     */
    function getUniqueId() {
        return Math.random().toString().substring(2, 18) + "-" + new Date().getTime();
    }

    /**
     * Returns the unique page id for the page.
     * 
     * @method getUniquePageId
     * @return {Number} The timestamp corresponding to the page load which is
     *         used as the unique page id.
     * @example
     *      SN.Tracker.getUniquePageId();
     */
    function getUniquePageId() {
        return uniquePageId;
    }

    /**
     * Appends the script id and the url parameters to the url.
     * 
     * @method appendUrlParams
     * @param {String} url The root url without the paramters.
     * @param {String} scriptId The id of the script tag corresponding to the call.
     * @param {String} params The key value pair parameters to be appended to the
     *        url as query strings.
     * @return {String} The url with the appended parameters.
     * @private
     */
    function appendUrlParams(url, scriptId, params) {
        var appendAmpersand = (url.length > 0) && (url.charAt(url.length - 1) != '?');
        if (appendAmpersand == true) {
            url += "&";
        } else {
            appendAmpersand = true;
        }
        url += "sId=" + scriptId;
        for ( var property in params) {
            if (appendAmpersand == true) {
                url += "&";
            } else {
                appendAmpersand = true;
            }
            if (typeof params[property] === "object") {
                url += (property + "=" + encodeURIComponent(JSON_247.stringify(params[property])));
            } else {
                url += (property + "=" + encodeURIComponent(params[property]));
            }
        }
        return url;
    }

    /**
     * Copies one parameter object to another.
     * 
     * @method copyParams
     * @param {Object} source The source object from where the properties will be copied.
     * @param {Object} destination The destination object where the properties
     *        will be copied to.
     * @private
     */
    function copyParams(source, destination) {
        if (SN.Utils.undefinedOrNull(source)) {
            return;
        }
        for ( var key in source) {
            if (!SN.Utils.undefinedOrNull(source[key])) {
                destination[key] = source[key];
            }
        }
    }

    /**
     * Returns the r Id from the full request id.
     * 
     * @method retrieveEventRequestId
     * @param {String} eventRequestId The complete r Id including the chunk information.
     * @return {String} The first two parts combined from a 4 part r-id.
     * @private
     */
    function retrieveEventRequestId(eventRequestId) {
        var requestIds = eventRequestId.split("-");
        return requestIds[0] + "-" + requestIds[1];
    }

    /**
     * Updates the status of the request.
     * 
     * @method updateStatus
     * @param {String} requestId The id of the request which needs an update.
     * @param {String} statusFlag The new status for the request
     * @private
     */
    function updateStatus(requestId, statusFlag) {
        try {
            var eventRequestId = retrieveEventRequestId(requestId);
            if (SN.Utils.undefinedOrNull(status[eventRequestId])) {
                return;
            }
            if (!SN.Utils.undefinedOrNull(statusFlag)) {
                if (!SN.Utils.undefinedOrNull(statusTracker)) {
                    statusTracker.call(this, eventRequestId, statusFlag);
                }
                delete status[eventRequestId];
                return;
            }
            status[eventRequestId] = status[eventRequestId] - 1;
    
            if (status[eventRequestId] == 0) {
                if (!SN.Utils.undefinedOrNull(statusTracker)) {
                    statusTracker.call(this, eventRequestId, "SUCCESS");
                }
                delete status[eventRequestId];
            }
        } catch (err) {
            SN.Logger.consoleLog("SN.Tracker: Error while updating the status for request id =" + requestId+ " "+err);
        }
    }

    /**
     * Saves the visitor related information coming from wowpx context.
     * 
     * @method setWowpxSessionData
     * @param {String} visitorGroup The visitor group that the person belongs to.
     * @param {String} targetPopulation The target population that the person belons to.
     * @param {String} targetId The target id of the person.
     * @param {Number} uniquePageId Unique page id of the page.
     * @param {Float} randomNumberForTargetPopulation Random number for
     *        determining the target population of the visitor.
     * @param {Float} randomNumberForVisitorGroup Random number for determining
     *        the visitor group of the visitor.
     * @example
     *      SN.Tracker.setWowpxSessionData("default","default","24",1359634974788,12.34,45.23);
     */
    function setWowpxSessionData(visitorGroup,targetPopulation,targetId,uniquePageId,randomNumberForTargetPopulation,randomNumberForVisitorGroup){
        if(!SN.Utils.undefinedOrNull(visitorGroup)&&!SN.Utils.undefinedOrNull(targetPopulation)&&!SN.Utils.undefinedOrNull(targetId)){            
            vg = visitorGroup;
            tp = targetPopulation;
            ti = targetId;
        }
        
        if(!SN.Utils.undefinedOrNull(uniquePageId)){
            uniquePageId = "wowpx_"+uniquePageId;
        }
        if(!SN.Utils.undefinedOrNull(randomNumberForTargetPopulation)&&!SN.Utils.undefinedOrNull(randomNumberForVisitorGroup)){
            rt = randomNumberForTargetPopulation;
            rv = randomNumberForVisitorGroup;
        }
    }
    init();
    return {
        constructAndMakeTrackingCall : constructAndMakeTrackingCall,
        processResponse : processResponse,
        removeElement : removeElement,
        getUniquePageId : getUniquePageId,
        setWowpxSessionData : setWowpxSessionData,
        getSessionData : getSessionData
    };
}());
/*3. sncustomxd*/
/**
 * @identity sncustomxd
 */
SN.Custom = SN.Custom || {};
SN.Custom.XdDataHandler = function(memo) {

    var CONST_APP_CUSTOM_EVENT = "wowpxstatechangeevent";
    var CONST_APP_TRACKING_EVENT = "wowpxtrackingevent";
    var CONST_TRACKING_EVENT_TYPE = "trackingEvent";
    var CONST_CUSTOM_EVENT_TYPE = "customEvent";

    var eventData = {};

        if (memo.data == null || typeof memo.data == "undefined") {
                memo.data = {};
        }
        memo.data.force = true;

    var CONST_SN_IFRAME_TAG = "sn_iframe";
    var snIframe = document.getElementById(CONST_SN_IFRAME_TAG);
    if (snIframe) {
        var iframeWin = snIframe.contentWindow || snIframe.contentDocument;
        if (iframeWin && iframeWin.SN && iframeWin.SN.EventManager) {
            if (memo.eventType == CONST_TRACKING_EVENT_TYPE) {
                iframeWin.SN.EventManager.fire(CONST_APP_TRACKING_EVENT, {
                    "sr" : memo.source,
                    "eventId" : memo.eventId,
                    "x" : memo.ex,
                    "agentId" : memo.agentId,
                    "formId" : memo.formId,
                    "fireImmediately" : true,
                    "data" : memo.data
                });
            } else if (memo.eventType == CONST_CUSTOM_EVENT_TYPE) {
                iframeWin.SN.EventManager.fire(CONST_APP_CUSTOM_EVENT, {
                    "sr" : memo.source,
                    "eventId" : memo.eventId,
                    "x" : memo.ex,
                    "agentId" : memo.agentId,
                    "formId" : memo.formId,
                    "fireImmediately" : true,
                    "data" : memo.data
                });
            }
        }
    }
}

XD = (function() {
    var handlerMap = {};

    function registerListener(origin, handler) {
        var oldHandler = handlerMap[origin] || null;
        handlerMap[origin] = handler;
        return oldHandler;
    }

    function process(origin, memo) {
        var handler = handlerMap[origin];
        if (handler) {
            handler(memo);
        }
    }

    function error() {
        if (typeof console != "undefined") {
            console.error(arguments);
        }
    }

    return {
        registerListener : registerListener,
        process : process
    };
})();

XD.registerListener("https://d1af033869koo7.cloudfront.net", SN.Custom.XdDataHandler);
XD.registerListener("http://d1af033869koo7.cloudfront.net", SN.Custom.XdDataHandler);
/*4. 247px*/
/**
 * @identity 247px
 * @requires tracker, sncustomxd, 247Conf
 */
if (typeof SN === "undefined") {
    SN = {};
}
/**
 * @module PE
 */
/**
 * The entry point class to load all the resources and initiate loding of the
 * framework.
 *
 * @class SN.247px
 * @static
 */
/**
 * Loads a very small 1 pixel image from an https:// location to intiate the
 * ssl handshake. This helps laoding of pspxd.html for the first iframe as the
 * handshake will be already complete.
 * 
 * @method loadSpacerImage
 * @private
 */
(function loadSpacerImage() {
    var spacer = new Image();
    spacer.style.display = "none";
    var SPACER_IMAGEPATH = SN.Conf.CONST_PSP_ROOT;
    spacer.src = "https://" + SPACER_IMAGEPATH + "/spacer.gif";
    try {
        var head = document.getElementsByTagName('head').item(0);
        void (head.appendChild(spacer));
    } catch (err) {
        if (typeof console != undefined) {
            SN.Logger.consoleLog("Error while loading image " + err);
        }
    }
} )();


//generate unique id (rand + timestamp) to be unique for all custom events in a given page.
try {
    var randStr = (new String(new Date().getTime())).valueOf() + "-" + (Math.floor(Math.random() * 1000000));
    window.pspSNTrackingId = randStr;
} catch (err) {
    if (typeof console != undefined) {
        SN.Logger.consoleLog("Error: Unable to generate unique id for custom events "+ err);
    }
}

/**
 * The class which provides the methods to create the 247SN iframe.
 *
 * @class SN.Tag
 * @static
 */
SN.Tag = (function() {
    var CONST_IFRAME_TAG = "iframe";
    var CONST_SN_IFRAME_TAG = "sn_iframe";
    var CONST_SN_IFRAME_STYLE_WIDTH = "0px";
    var CONST_SN_IFRAME_STYLE_HEIGHT = "0px";
    var CONST_SN_IFRAME_STYLE_BORDER = "0px";
    var CONST_SN_IFRAME_STYLE_POSITION = "absolute";
    var CONST_SN_IFRAME_STYLE_LEFT = "-50px";
    var CONST_SN_IFRAME_STYLE_TOP = "-50px";
    var customTrackingEnabled = null;
    var documentDomain = document.domain;

    var iframeUrl = "";

    /**
     * This method creates the 247SN iframe in the head of the page.
     * 
     * @method createSNIframeOnHead
     * @param {String} cdnVersion The version of the cloudfront static resources.
     * @param {String} pspVersion The version of the framework to be laoded.
     */
    function createSNIframeOnHead(cdnVersion, pspVersion) {
        var tagframe = document.createElement(CONST_IFRAME_TAG);
        tagframe.style.width = CONST_SN_IFRAME_STYLE_WIDTH;
        tagframe.style.height = CONST_SN_IFRAME_STYLE_HEIGHT;
        tagframe.style.border = CONST_SN_IFRAME_STYLE_BORDER;
        tagframe.style.position = CONST_SN_IFRAME_STYLE_POSITION;
        tagframe.style.top = CONST_SN_IFRAME_STYLE_TOP;
        tagframe.style.left = CONST_SN_IFRAME_STYLE_LEFT;
        tagframe.async = true;
        tagframe.id = CONST_SN_IFRAME_TAG;

        if (SN.Conf.DOMAIN_VS_PARAMETIZED_PATH_AND_EXTENSION != null && (SN.Conf.DOMAIN_VS_PARAMETIZED_PATH_AND_EXTENSION[documentDomain] != undefined) && (SN.Conf.DOMAIN_VS_PARAMETIZED_PATH_AND_EXTENSION[documentDomain] != null)) {
            iframeUrl = SN.Conf.DOMAIN_VS_PARAMETIZED_PATH_AND_EXTENSION[documentDomain];
        } else {
            SN.loadTrackingScript("CouldntDeterminePathAndExtensionFor247SN", "", "", SN.Conf.CUSTOM_TRACK_SERVER, SN.Conf.CONST_PSP_KEY, SN.Constants.LOGLEVEL_ERROR);
            return;
        }
        tagframe.src = iframeUrl + "#key=" + SN.Conf.CONST_PSP_KEY + "&" + "documentDomain=" + documentDomain + "&version=" + cdnVersion + "&pspVersion=" + pspVersion + "&cdnPath=" + SN.Conf.CDN_DOMAIN + "&r=" + SN.Conf.CONST_PXFWK_ID;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(tagframe, s);
        //document.body.appendChild(tagframe);`
    }

    function isCustomTrackingEnabled(){     
        if(!SN.Utils.undefinedOrNull(customTrackingEnabled)){
            return customTrackingEnabled=="true";
        }
        
        if(window.localStorage){
            customTrackingEnabled=window.localStorage.getItem(SN.Constants.IS_CUSTOM_TRACKING_ENABLED);
        }
        
        if(SN.Utils.undefinedOrNull(customTrackingEnabled)){
            if((Math.floor(Math.random() * (100)))<=SN.Conf.CUSTOM_TRACKING_PERCENTAGE){
                customTrackingEnabled="true";
            }
            else{
                customTrackingEnabled="false";
            }
            if(window.localStorage)
                window.localStorage.setItem(SN.Constants.IS_CUSTOM_TRACKING_ENABLED,customTrackingEnabled);
        }
        return customTrackingEnabled=="true";
    }
    
    if (isCustomTrackingEnabled()) {
        //SN.loadTrackingScript("247pxLoading", "", "", SN.Conf.CUSTOM_TRACK_SERVER, SN.Conf.CONST_PSP_KEY, SN.Constants.LOGLEVEL_INFO);
    }
    isCustomTrackingEnabled();
    var me = {
        createSNIframeOnHead : createSNIframeOnHead
    };
    return me;
})();


/*5. resourceloader*/
/**
 * @identity resourceloader
 * @requires 247px, uAParser
 */
if (typeof SN === "undefined") {
    SN = {};
}
/**
 * @module PE
 */
/**
 * Class to check and laod the framework according to the versions, browser
 * compatibility and user environment.
 * 
 * @class SN.ResourseLoader
 * @static
 */
SN.ResourceLoader = (function() {
    /**
    * Constant variable to know whether the user is active or not.
    * @property CONST_ACTIVE
    * @final
    * @type String
    * @default "a"
    * @private
    */
    var CONST_ACTIVE = "a";
    /**
    * Constant variable to know whether the user is bypassed.
    * @property CONST_BY_PASSED
    * @final
    * @type String
    * @default "b"
    * @private
    */
    var CONST_BY_PASSED = "b";
    /**
    * Variable to store the decision to serve user made by the code.
    * @property decision
    * @type String
    * @default null
    * @private
    */
    var decision = null;
    /**
    * Placeholder for Windows string.
    * @property CONST_WINDOWS_NAME
    * @final
    * @type String
    * @default "Windows"
    * @private
    */
    var CONST_WINDOWS_NAME = "Windows";
    /**
    * Placeholder for Mac OS string.
    * @property CONST_MAC_NAME
    * @final
    * @type String
    * @default "MacOS"
    * @private
    */
    var CONST_MAC_NAME = "MacOS";
    /*
     * client key and resource id related
     */

    /**
    * PSP version - default or test.
    * @property pspVersion
    * @type String
    * @default "default"
    * @private
    */
    var pspVersion = "default";
    /**
    * The cdn version for the static resources.
    * @property cdnVersion
    * @type String
    * @default null
    * @private
    */
    var cdnVersion = null;

    /**
    * Placeholder key for event data.
    * @property CONST_EVENT_DATA
    * @final
    * @type String
    * @default "e"
    * @private
    */
    var CONST_EVENT_DATA = "e";
    /**
    * Placeholder key for Browser Data.
    * @property CONST_BROWSER_DATA
    * @final
    * @type String
    * @default "bd"
    * @private
    */
    var CONST_BROWSER_DATA = "bd";
    /**
    * Placeholder key for Browser Language.
    * @property CONST_BROWSER_LANG
    * @final
    * @type String
    * @default "bl"
    * @private
    */
    var CONST_BROWSER_LANG = "bl";
    /**
     * Placeholder key for Cookies enabled.
     * @property CONST_STORE_ENABLED
     * @final
     * @type String
     * @default "ce"
     * @private
     */
     var CONST_STORE_ENABLED = "ce";
    /**
    * Placeholder key for event string.
    * @property CONST_EVENT_STRING
    * @final
    * @type String
    * @default "si"
    * @private
    */
    var CONST_EVENT_STRING = "si";
    /**
    * Placeholder key for event code.
    * @property CONST_EVENT_CODE
    * @final
    * @type String
    * @default "ec"
    * @private
    */
    var CONST_EVENT_CODE = "ec";
    /**
    * Placeholder key for referrer.
    * @property CONST_REFERRER
    * @final
    * @type String
    * @default "rf"
    * @private
    */
    var CONST_REFERRER = "rf";
    /**
    * Constant event code for environment not supported event.
    * @property BROWSER_NOT_SUPPORTED_EVENT
    * @final
    * @type String
    * @default "500001"
    * @private
    */
    var BROWSER_NOT_SUPPORTED_EVENT = "500001";
    /**
    * Placeholder key for environment not supported event.
    * @property CONST_ENV_NOT_SUPPORTED
    * @final
    * @type String
    * @default "ENVNOTSUPPORTED"
    * @private
    */
    var CONST_ENV_NOT_SUPPORTED = "ENVNOTSUPPORTED";
    /**
    * Object containing the pspVersion mappings.
    * @property VERSION
    * @final
    * @type Object
    * @default {"t": "test", "d": "default"}
    * @private
    */
    var VERSION = {
        "t" : "test",
        "d" : "default"
    };
    /**
    * Reference to {{#crossLink "SN.Logger"}}{{/crossLink}}
    * @property logger
    * @final
    * @type Object
    * @private
    */
    var logger = SN.Logger;

    /**
     * This method checks the decision and version parameters and accordingly,
     * tries to load the framework resource.
     * 
     * @method load
     * @private
     */
    function load() {
        if (typeof decision == "undefined" || SN.Utils.undefinedOrNull(decision)) {
            logger.consoleLog("decision doesn't exist, getting decision !!");
            getDecision();
        } else if (decision == CONST_ACTIVE) {
            if (typeof pspVersion == "undefined" || SN.Utils.undefinedOrNull(pspVersion)
                    || typeof cdnVersion == "undefined" || SN.Utils.undefinedOrNull(cdnVersion)) {
                if (typeof console != "undefined") {
                    SN.Logger
                            .consoleLog("decision exists but not pspversion or cdnversion, getting decision !!");
                }
                getDecision();
            } else {
                /*
                 * if decision is active and version information is also
                 * present, load the pxoe resource accordingly.
                 */
                SN.Tag.createSNIframeOnHead(cdnVersion, VERSION[pspVersion]);
            }
        } else {
            /*
             * if decision is not active, no need to load the resource. just log
             * and return.
             */
            logger.consoleLog("Decision != active, not initializing framework");
        }
    }

    /**
     * This method decides whether the server should bypass the user or load the framework.
     * 
     * @method getDecision
     * @private
     */
    function getDecision() {
        try {

            var rand = Math.random().toString().substring(2, 4);
            if (rand < SN.Conf.BYPASS_PERCENTAGE) {
                decision = CONST_BY_PASSED;
            } else {
                decision = CONST_ACTIVE;
            }
            if (decision == CONST_ACTIVE) {
                rand = Math.random().toString().substring(2, 4);
                rand = parseInt(rand);
                if (rand < SN.Conf.TEST_PERCENTAGE) {
                    pspVersion = "t";
                    SN.Conf.CONST_PSP_VERSION = "test";
                } else {
                    pspVersion = "d";
                    SN.Conf.CONST_PSP_VERSION = "default";
                }
            }
            cdnVersion = SN.Conf.CONST_CDN_VERSION;
            /*
             * load the resource according to the parameters
             */
            load();
        } catch (err) {
            logger.consoleLog("Error while processing decision", err);
        }
    }

    /**
     * Splits a version string and converts it into integer value, removes all
     * alpha and special characters.
     * 
     * @method spliteAndConvertToInt
     * @param {string} Version string
     * @example 
     *      splitAndConvertToInt("v1.6.3")
     * @return {Array} An Integer array composed of the version heirarchy.
     * @private
     */
    function splitAndConvertToInt(version) {
        var array = version.split(".");
        for ( var i in array) {
            array[i] = parseInt(array[i]);
        }
        return array;
    }

    /**
     * Compares two browser versions.
     * 
     * @method compareVersions 
     * @param {String} currentVersion The current version of the user browser.
     * @param {String} lowestSupportedVersion The lowest version supported by the framework.
     * @example
     *      compareVersions("16.0.1","3.5.6")
     * @return {Boolean} True if currentVersion is greater than
     * lowestSupportedVersion, False otherwise
     * @private
     */
    function compareVersions(currentVersion, lowestSupportedVersion) {
        /*
         * returns true if currentVersion >=lowestSupportedVersion returns
         * false, if otherwise
         */
        var currentArray = splitAndConvertToInt(currentVersion);
        var lowestSupportedArray = splitAndConvertToInt(lowestSupportedVersion);
        var noOfElementsToBeCompared = currentArray.length;
        if (currentArray.length > lowestSupportedArray.length) {
            noOfElementsToBeCompared = lowestSupportedArray.length;
        }
        for ( var i = 0; i < noOfElementsToBeCompared; i++) {
            if (currentArray[i] > lowestSupportedArray[i]) {
                return true;
            } else if (currentArray[i] < lowestSupportedArray[i]) {
                return false;
            }
        }
        if (i == noOfElementsToBeCompared) // same version
        {
            return true;
        }
    }

    /**
     * Checks whether the user browser is supported to load the framework.
     * 
     * @method isBrowserSupported
     * @return {Boolean} True if the browser is supported by the framework,
     * False otherwise
     * @private
     */
    function isBrowserSupported() {
        try {
            var uAParser = SN.UserAgentParser;
            var currentVersion;
            for ( var key in uAParser.browserList) {

                if (uAParser.isBrowser(key) == true) {
                    currentVersion = uAParser.browserList[key].getVersion();
                    if (compareVersions(currentVersion, uAParser.browserList[key].lowestSupportedVersion)) {
                        for ( var blackListedVersion in uAParser.browserList[key].blacklistedVersions) {
                            if (currentVersion == uAParser.browserList[key].blacklistedVersions[blackListedVersion]) {
                                // Blacklisted versions
                                return false;
                            }
                        }
                        // supported browser + supported version
                        return true;
                    } else {
                        // Unsupported version of supported browser
                        return false;
                    }
                }
            }
            // Browser not supported
            return false;
        } catch (err) {
            logger.consoleLog("Error while evaluating isBrowserSupported:" + err);
            return false;
        }
    }

    /**
     * Checks whether the user Operating System is supported to load the framework.
     * 
     * @method isNotOSSupported
     * @return {Boolean} True if the OS is not supported, False otherwise.
     * @private
     */
    function isNotOSSupported() {
        try {
            var osType = SN.UserAgentParser.getOSType();
            if (osType.indexOf(CONST_WINDOWS_NAME) == -1 && osType.indexOf(CONST_MAC_NAME) == -1 && osType.indexOf("Andriod") != -1) {
                return true;
            } else {
                return false;
            }
        } catch (err) {
            logger.consoleLog("Error while evaluating isNotOSSupported:", err);
            return true;
        }
    }

    /**
     * Appends the url with the given parameters after properly encoding them.
     * 
     * @method appendUrlParams
     * @param {String} url The base URL.
     * @param {Object} params The object containing various parameters to be
     * appended to the url.
     * @example
     *      appendUrlParam("http://google.com", {"psp": 5.3, "cdn": 1.2})
     * @return {String} The complete url containing the parameters as querystrings.
     * @private
     */
    function appendUrlParams(url, params) {
        var appendAmpersand = (url.length > 0) && (url.charAt(url.length - 1) != '?');
        for ( var property in params) {
            if (appendAmpersand == true) {
                url += "&";
            } else {
                appendAmpersand = true;
            }
            if (typeof params[property] === "object" || (isArray(params))) {
                url += (property + "=" + encodeURIComponent(JSON_247.stringify(params[property])));
            } else {
                url += (property + "=" + encodeURIComponent(params[property]));
            }
        }
        return url;
    }

    /**
     * Checks whether the imput is an Array or not.
     * 
     * @method isArray
     * @param {Object} obj The input object to be checked.
     * @return {Boolean} True if the input is Array type, False otherwise.
     * @private
     */
    function isArray(obj) {
        return (obj.constructor == Array);
    }

    /**
     * The method makes a tracking call if the user environment and browser is
     * supported by the framework. 
     * 
     * @method initialize
     * @private
     */
    function initialize() {
        // check for browser compatibility
        if ((!isBrowserSupported()) || !(navigator.cookieEnabled) || (isNotOSSupported())) {
            try {
                //already present, if so, use it, don't make the cpxt call.
                var uAParser = SN.UserAgentParser;
                var trackingData = {};
                var eventData = {};
                // event data..         
                eventData[CONST_EVENT_STRING] = CONST_ENV_NOT_SUPPORTED;
                eventData[CONST_BROWSER_DATA] = navigator.userAgent;
                eventData[CONST_STORE_ENABLED] = navigator.cookieEnabled;
                eventData[CONST_EVENT_CODE] = BROWSER_NOT_SUPPORTED_EVENT;
                eventData[CONST_BROWSER_LANG] = uAParser.getBrowserLanguage();
                eventData[CONST_REFERRER] = document.referrer;
                //trackingData[CONST_EVENT_DATA] = JSON_247.stringify(eventData);
                var metaData = {
                    key : SN.Conf.CONST_PSP_KEY
                };
                trackingData[CONST_EVENT_DATA] = eventData;
                SN.Tracker.constructAndMakeTrackingCall(metaData, eventData);
            } catch (err) {
                SN.Logger.consoleLog("Error while making a tracking call: "+err);
            }
            return;
        }
        if (!SN.Conf.IS_DS_REQUIRED) {
            SN.Tag.createSNIframeOnHead(SN.Conf.CONST_CDN_VERSION, SN.Conf.PSP_VERSION);
            return;
        }
                    /*
                     * call decision maker
                     */
        SN.CustomDecisionServer.init({
            'start' : 600,
            'stop'  : 2359
        })
        var response = SN.CustomDecisionServer.getDecision();
        decision = response.decision;
        pspVersion = response.pspVersion;
        cdnVersion = response.cdnVersion;
        load();
    }

    initialize();
}());